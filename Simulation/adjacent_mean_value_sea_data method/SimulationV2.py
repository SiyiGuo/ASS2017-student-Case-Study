
from itertools import combinations
import time
import math
import xlrd
from operator import itemgetter

#this version does not care about other, and we let them to be the most useless land, or we define another item
def ncr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n-r)

def calculation_volume():
	planA = ncr(20,6)*ncr(14,2)*ncr(12,2)*ncr(10,2)*ncr(8,2)
	planB = ncr(20,2)*ncr(18,2)*ncr(16,2)*ncr(14,2)*ncr(12,6)    

	print (planA, planB)

def read_excel():
	filename = "data_conver_seadata_otherscore included.xlsm"
	file_data = xlrd.open_workbook(filename)
	table = file_data.sheets()[0]
	return table

def remove_0(row):
	return [data for data in row if data != 0]


first_k_element = 14	#find the first k element in score list
global first_k_element

def candidate_list():
 
	#appending data
	score_table = read_excel()

	#define the data set for 
	agriculture_score = []
	fishing_score = []
	private_housing_score = []
	recreation_score = []
	conservation_score = []
	other_score = []

	#from row_index 57 to 77 are the score data in the excel file
	#read the score from excel
	score_rowindex_range = [x for x in range(57, 77)]
	for row_index in score_rowindex_range:
		row_data = score_table.row_values(row_index)
		#row_data is in the form:
		#blcok_number, agriculture, fishing , housing, recreation, conservation
		#0				1 			2 			3	,	4		, 5
		agriculture_score.append((row_data[0], row_data[1]))
		fishing_score.append((row_data[0], row_data[2]))
		private_housing_score.append((row_data[0], row_data[3]))
		recreation_score.append((row_data[0], row_data[4]))
		conservation_score.append((row_data[0], row_data[5]))
		other_score.append((row_data[0], row_data[6]))

	#sorint the score and find top k's place for this function of land
	agriculture = [int(x) for x,y in sorted(agriculture_score, key = itemgetter(1), reverse = True)][:first_k_element]
	fishing = [int(x) for x,y in sorted(fishing_score, key = itemgetter(1), reverse = True)][:first_k_element]
	private_housing = [int(x) for x,y in sorted(private_housing_score, key = itemgetter(1), reverse = True)][:first_k_element]
	recreation = [int(x) for x,y in sorted(recreation_score, key = itemgetter(1), reverse = True)][:first_k_element]
	conservation = [int(x) for x,y in sorted(conservation_score, key = itemgetter(1), reverse = True)][:first_k_element]
	other = [int(x) for x,y in sorted(other_score, key = itemgetter(1), reverse = True)][:first_k_element]

	####################################ADDING RESTRICTION HERE##########################################################
	#reducting the candidate lists by sea_level, adjacent matrix and duck numbers
	sea_level_danger = [4, 5, 7, 14, 15, 16, 18] #this forbidden place is generated by a calculation from matlab
	invalid_conservation = [1,2,3,4,5,6] #this place is place with 0 ducks

		#since it is a public area, it should connected to two area, whatever is public or private
	public_area_list = [5, 6, 8, 9, 10, 11, 14, 15, 16, 17, 18, 19 ,20] #read from adjacent matrix

	for i in range(first_k_element):
		if private_housing[i] in sea_level_danger:
			private_housing[i] = 0
		if recreation[i] in sea_level_danger or recreation[i] not in public_area_list:
			recreation[i] = 0
		#remoce the case there is no duck
		if (conservation[i] in sea_level_danger) or (conservation[i] in invalid_conservation):
			conservation[i] = 0
		elif conservation[i] not in public_area_list:
			conservation[i] = 0


	private_housing = remove_0(private_housing)
	recreation = remove_0(recreation)
	conservation = remove_0(conservation)


	#print out the result
	print ("agriculture:",agriculture)
	print ("fishing", fishing)
	print ("private_housing:", private_housing)
	print ("recreation:", recreation)
	print ("conservation:", conservation)
	print ("other:", other)

	return agriculture, fishing, private_housing, conservation, recreation, other

def calculate_score(current_plan):
	#take a list with length 6
	#data in the file in the form:
	#agriculture, fishing, housing, recreation, convervation, other
	score = 0
	#where row index 57 means the score in block1
	score_rowindex_range = [x for x in range(57, 77)]

	mode = 1
	for function in current_plan:
		#function 1 = conservation, function = 2 recreation, function = 3 fishing
		#function 4 = agriculture, function = 5 private housing function =6 other area score
		for block in function:
			#when block = 1, 1+56 = 57 which is blcok 1 data in score_table
			block_data = score_table.row_values(block + 56) 
			if mode == 1:
				score += block_data[5]
			if mode ==2:
				score += block_data[4]
			if mode ==3:
				score += block_data[2]
			if mode ==4:
				score += block_data[1]
			if mode ==5:
				score += block_data[3]
			if mode ==6:
				score += block_data[6]
		mode += 1

	return score
def block_max_score_function(block):
	block_data = score_table.row_values(block + 56)
	max_score = 0
	function_num = 0
	for i in range(1,6):
		if block_data[i] > max_score:
			max_score = block_data[i]
			function_num = i

	function = score_table.row_values(56)[function_num]

	return ((function, block, max_score))


#simulation part
def simulation(agriculture, fishing, private_housing, conservation, recreation, other):
	print ("\nstart simulation\n")
	start_time = time.time()

	total_result = []
	temp_result = []

	max_score = 0
	best_comb = []

	#determin the 12 area that is necessary by the council rule
	for conserve in combinations(conservation, 3):
		temp_result = []
		temp_result.append(conserve)
		for recreate in combinations(set(recreation) - set(conserve),3):
			temp_result.append(recreate)
			for fish in combinations(set(fishing) - set(recreate)- set(conserve), 2):
				temp_result.append(fish)
				for agri in combinations(set(agriculture) - set(fish) - set(recreate)- set(conserve),2):
					temp_result.append(agri)
					for housing in combinations(set(private_housing) - set(fish) - set(recreate) - set(agri)- set(conserve),2):
						temp_result.append(housing)

						current_plan_score = calculate_score(temp_result)

						elapsed_time = time.time() - start_time

						if current_plan_score > max_score:
							max_score = current_plan_score
							#list = old_list operation will not generate two list, this is pythoon's feature
							best_comb = temp_result.copy()
							print (best_comb, max_score, elapsed_time )
						
						#go into the next combination
						temp_result.remove(temp_result[-1])
			
					temp_result.remove(temp_result[-1])
		
				temp_result.remove(temp_result[-1])
	
			temp_result.remove(temp_result[-1])

	elapsed_time = time.time() - start_time

	print('\nThis is a simulation part:')
	print ("this is best combination")
	#in the form conservation, recreation, fishing, agriculture, housing, other_area
	print ("conservation", "  recreation", " fishing", "agriculture", "housing")
	public_score = calculate_score(best_comb[:2])
	private_score = calculate_score(best_comb[2:])
	print(best_comb, max_score, public_score, private_score)
	print ("total time consuming in seconds", elapsed_time)

	#calculate the rest land with their highest score
	determined_block = [block for function in best_comb for block in function]
	remaining_block = set([x for x in range(1,21)]) - set(determined_block)
	for block in remaining_block:
		(function, block_num, score) = block_max_score_function(block)
		max_score += score
		print (block_num, ":", function, score)
	print ("the total scoer for the whole town is", max_score)

	#verified against calculating the highest score from each block disregard to the council rule
	print ("\nbelow is a rough verification")
	verified_score = 0
	for block in range(1,21):
		(function, block_num, score) = block_max_score_function(block)
		verified_score += score
		print (block_num, ":", function, score)
	print ("The total score for verification is", verified_score)
	print ("the difference between town planning and verified score is", max_score - verified_score)


agriculture, fishing, private_housing, conservation, recreation, other = candidate_list()

score_table = read_excel()
global score_table

simulation(agriculture, fishing, private_housing, conservation, recreation, other)




















