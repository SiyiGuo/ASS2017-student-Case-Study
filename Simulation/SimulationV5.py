
from itertools import combinations
from operator import itemgetter
import statistics
import math
import xlrd


def read_excel(filename):
	file_data = xlrd.open_workbook(filename)
	table = file_data.sheets()[0]
	return table

def remove_0(row):
	return [data for data in row if data != 0]

#generating candidate list
def sea_variance():
	sea_data = read_excel("Complete data set.xlsx");
	block_var = []
	for block in range(1,21):
		row_data = sea_data.row_values(block)
		block_var.append((block, statistics.variance(row_data)))

	max_var = max([y for (x,y) in block_var])
	block_var_score = [(x, y / max_var ) for (x,y) in block_var]

	#for tide power station, sea variance as high as possible
	power_score = sorted(block_var_score, key = itemgetter(1), reverse = True)
	#for harbour, sea variance as low as possible
	harbour_score = [(x, 1-y) 
					for (x,y) in sorted(block_var_score, key = itemgetter(1))]

	print(power_score)
	print(harbour_score)

	power_cand = [x for (x,y) in power_score]
	harbour_cand = [x for (x,y) in harbour_score]

	return power_cand,harbour_cand, block_var_score

def shorten_candidate(score_list):
	score_list = sorted(score_list, key = itemgetter(1), reverse = True)
	result =  [int(x) for x,y in score_list][:first_k_element]
	return result

def candidate_list():

	#define the data set for 
	agriculture_score = []
	fishing_score = []
	private_housing_score = []
	recreation_score = []
	conservation_score = []
	other_score = []

	#from row_index 57 to 77 are the score data in the excel file
	#read the score from excel
	score_rowindex_range = [x for x in range(57, 77)]
	for row_index in score_rowindex_range:
		row_data = score_table.row_values(row_index)
		#row_data is in the form:
		#blcok_number, agriculture, fishing , housing, recreation, conservation
		#0				1 			2 			3	,	4		, 5
		agriculture_score.append((row_data[0], row_data[1]))
		fishing_score.append((row_data[0], row_data[2]))
		private_housing_score.append((row_data[0], row_data[3]))
		recreation_score.append((row_data[0], row_data[4]))
		conservation_score.append((row_data[0], row_data[5]))

	#sorint the score and find top k's place for this function of land
	agriculture = shorten_candidate(agriculture_score)
	fishing = shorten_candidate(fishing_score)
	private_housing = shorten_candidate(private_housing_score)
	recreation = shorten_candidate(recreation_score)
	conservation = shorten_candidate(conservation_score)
	temp_power, temp_harbour, block_var_score= sea_variance()
	electricity = temp_power[:first_k_element]
	harbour = temp_harbour[:first_k_element]

	##########################ADDING RESTRICTION HERE################
	#reducting the candidate lists by sea_level, connectivity and duck numbers
	#this forbidden place is generated by a calculation from matlab
	sea_level_danger = [4, 5, 7, 14, 15, 16, 18] 

	#this place is place with 0 ducks
	zero_duck_zone = [1,2,3,4,5,6] 

	#Every public area should connected to two area	
	#read from adjacent matrix
	public_area_list = [5, 6, 8, 9, 10, 11, 14, 15, 16, 17, 18, 19 ,20] 

	for i in range(first_k_element):

		if private_housing[i] in sea_level_danger:
			private_housing[i] = 0

		if (recreation[i] in sea_level_danger or 
			recreation[i] not in public_area_list):
			recreation[i] = 0

		#remoce the case there is no duck
		if (conservation[i] in sea_level_danger or 
			conservation[i] in zero_duck_zone or
			conservation[i] not in public_area_list):
			conservation[i] = 0



	private_housing = remove_0(private_housing)
	recreation = remove_0(recreation)
	conservation = remove_0(conservation)


	#print out the result
	print("Candidate list as followed")
	print ("agriculture:",agriculture)
	print ("fishing", fishing)
	print ("private_housing:", private_housing)
	print ("recreation:", recreation)
	print ("conservation:", conservation)

	return agriculture, fishing, private_housing, conservation, recreation, electricity, harbour, block_var_score

#simulation part
def block_max_score_function(block):
	block_data = score_table.row_values(block + 56)
	max_score, function_num = 0, 0
	for i in range(1,6):
		if block_data[i] > max_score:
			max_score = block_data[i]
			function_num = i

	function = score_table.row_values(56)[function_num]

	return ((function, block, max_score))

def remaining_candidate(waiting_list, temp_result):
	result = set(waiting_list)
	for temp in temp_result:
		result -= set(temp)

	return result

def calculate_score(current_plan):
	#take a list with length 6
	#data in the file in the form:
	#agriculture, fishing, housing, recreation, convervation, other
	score = 0
	#where row index 57 means the score in block1
	score_rowindex_range = [x for x in range(57, 77)]

	mode = 1
	for function in current_plan:
		#function 1 = conservation, function = 2 recreation, function = 3 fishing
		#function 4 = agriculture, function = 5 private housing function =6 other area score
		for block in function:
			#when block = 1, 1+56 = 57 which is blcok 1 data in score_table
			block_data = score_table.row_values(block + 56) 
			if mode == 1:
				score += block_data[5]
			if mode ==2:
				score += block_data[4]
			if mode ==3:
				score += block_data[2]
			if mode ==4:
				score += block_data[1]
			if mode ==5:
				score += block_data[3]
			if mode ==6:
				return score
				#score += block_data[6]
		mode += 1

	return score

def simulation(agriculture, fishing, private_housing, conservation, recreation, electricity, harbour, block_var_score):
	
	print ("\nstart simulation\n")

	#1 for max block, 2 for block with 16
	total_result, temp_result, best_comb, best_comb2 = [], [], [], []

	max_score, max_score2 = 0, 0

	count = 0
	#determin the 12 area that is necessary by the council rule
	for conserve in combinations(conservation, 3):
		temp_result = []
		temp_result.append(conserve)
		for recreate in combinations(remaining_candidate(recreation, temp_result),3):
			temp_result.append(recreate)
			for fish in combinations(remaining_candidate(fishing, temp_result), 2):
				temp_result.append(fish)
				for agri in combinations(remaining_candidate(agriculture, temp_result),2):
					temp_result.append(agri)
					for housing in combinations(remaining_candidate(private_housing, temp_result),2):
						temp_result.append(housing)
						for elec in combinations(remaining_candidate(electricity, temp_result),1):
							temp_result.append(elec)
							for har in combinations(remaining_candidate(harbour, temp_result),1):
								temp_result.append(har)

								current_plan_score = calculate_score(temp_result)
								current_plan_score += block_var_score[elec[0] - 1][1]
								current_plan_score2 = current_plan_score

								#excluding block 16 because it is a isolated island
								if har[0] != 16:
									current_plan_score += (1-block_var_score[har[0] - 1][1])
								else:
									current_plan_score2 += (1-block_var_score[har[0] - 1][1])
									if current_plan_score2 > max_score2:
										max_score2 = current_plan_score2
										best_comb2 = temp_result.copy()
										print("\n")
										print (best_comb2, max_score2)


								if current_plan_score > max_score:
									max_score = current_plan_score
									#list = old_list operation will not generate two list, 
									#this is pythoon's feature
									best_comb = temp_result.copy()
									print("\n")
									print (best_comb, max_score)

								#a small line for fun
								print("number of combination tried:", count, "\r", end = "")
								count += 1
						
								#go into the next combination
								temp_result.remove(temp_result[-1])

							temp_result.remove(temp_result[-1])

						temp_result.remove(temp_result[-1])

					temp_result.remove(temp_result[-1])
		
				temp_result.remove(temp_result[-1])
	
			temp_result.remove(temp_result[-1])


	#the case exclude block 16 as harbor
	#result for first 13 elements
	print ("The is second best combination")
	print ("conservation", "  recreation", " fishing", "agriculture", "housing",
			"elec", "harbour")
	print(best_comb, max_score)

	#calculate the rest land with their highest score
	determined_block = [block for function in best_comb for block in function]
	remaining_block = set([x for x in range(1,21)]) - set(determined_block)
	for block in remaining_block:
		(function, block_num, score) = block_max_score_function(block)
		max_score += score
		print (block_num, ":", function, score)
	print ("the total scoer for the whole town is", max_score)

	#the case use block 16 as harbor
	#result for first 13 elements
	print ("The is best combination")
	print ("conservation", "  recreation", " fishing", "agriculture", "housing",
			"elec", "harbour")
	print(best_comb2, max_score2)

	#calculate the rest land with their highest score
	determined_block = [block for function in best_comb2 for block in function]
	remaining_block = set([x for x in range(1,21)]) - set(determined_block)
	for block in remaining_block:
		(function, block_num, score) = block_max_score_function(block)
		max_score2 += score
		print (block_num, ":", function, score)
	print ("the total scoer for the whole town is", max_score2)




global first_k_element
first_k_element = 20	#find the first k element in score list

global score_table
score_table = read_excel("data_conver_seadata included.xlsm")


agriculture, fishing, private_housing, conservation, recreation, electricity, harbour, block_var_score= candidate_list()

simulation(agriculture, fishing, private_housing, conservation, recreation, 
			electricity, harbour, block_var_score)





















